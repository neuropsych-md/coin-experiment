# MiSIT (Modified Simon Interference Task)
# --------------------------------------------------------------------------
#
# required files:
#     MiSIT.pcl
#     events files in the input\ folder
#         gbNW_poNE_1.txt, gbNW_poNE_2.txt
#         poNW_gbNE_1.txt, poNW_gbNE_2.txt
#     stim1 PNGs in the stimuli\ folder
#         green-SENW-330.png, green-SWNE-030.png
#         green-SENW-300.png, green-SWNE-060.png
#         blue-SENW-330.png, blue-SWNE-030.png
#         blue-SENW-300.png, blue-SWNE-060.png
#         pink-SENW-330.png, pink-SWNE-030.png
#         pink-SENW-300.png, pink-SWNE-060.png
#         orange-SENW-330.png, orange-SWNE-030.png
#         orange-SENW-300.png, orange-SWNE-060.png
#     stim2 PNGs in the stimuli\ folder
#         01_green-SENW-330_farbe-left.png, 02_green-SENW-330_farbe-right.png
#         03_green-SENW-330_orient-left.png, 04_green-SENW-330_orient-right.png
#         05_green-SENW-300_farbe-left.png, 06_green-SENW-300_farbe-right.png
#         07_green-SENW-300_orient-left.png, 08_green-SENW-300_orient-right.png
#         09_green-SWNE-030_farbe-left.png, 10_green-SWNE-030_farbe-right.png
#         11_green-SWNE-030_orient-left.png, 12_green-SWNE-030_orient-right.png
#         13_green-SWNE-060_farbe-left.png, 14_green-SWNE-060_farbe-right.png
#         15_green-SWNE-060_orient-left.png, 16_green-SWNE-060_orient-right.png
#         17_blue-SENW-330_farbe-left.png, 18_blue-SENW-330_farbe-right.png
#         19_blue-SENW-330_orient-left.png, 20_blue-SENW-330_orient-right.png
#         21_blue-SENW-300_farbe-left.png, 22_blue-SENW-300_farbe-right.png
#         23_blue-SENW-300_orient-left.png, 24_blue-SENW-300_orient-right.png
#         25_blue-SWNE-030_farbe-left.png, 26_blue-SWNE-030_farbe-right.png
#         27_blue-SWNE-030_orient-left.png, 28_blue-SWNE-030_orient-right.png
#         29_blue-SWNE-060_farbe-left.png, 30_blue-SWNE-060_farbe-right.png
#         31_blue-SWNE-060_orient-left.png, 32_blue-SWNE-060_orient-right.png
#         33_pink-SENW-330_farbe-left.png, 34_pink-SENW-330_farbe-right.png
#         35_pink-SENW-330_orient-left.png, 36_pink-SENW-330_orient-right.png
#         37_pink-SENW-300_farbe-left.png, 38_pink-SENW-300_farbe-right.png
#         39_pink-SENW-300_orient-left.png, 40_pink-SENW-300_orient-right.png
#         41_pink-SWNE-030_farbe-left.png, 42_pink-SWNE-030_farbe-right.png
#         43_pink-SWNE-030_orient-left.png, 44_pink-SWNE-030_orient-right.png
#         45_pink-SWNE-060_farbe-left.png, 46_pink-SWNE-060_farbe-right.png
#         47_pink-SWNE-060_orient-left.png, 48_pink-SWNE-060_orient-right.png
#         49_orange-SENW-330_farbe-left.png, 50_orange-SENW-330_farbe-right.png
#         51_orange-SENW-330_orient-left.png, 52_orange-SENW-330_orient-right.png
#         53_orange-SENW-300_farbe-left.png, 54_orange-SENW-300_farbe-right.png
#         55_orange-SENW-300_orient-left.png, 56_orange-SENW-300_orient-right.png
#         57_orange-SWNE-030_farbe-left.png, 58_orange-SWNE-030_farbe-right.png
#         59_orange-SWNE-030_orient-left.png, 60_orange-SWNE-030_orient-right.png
#         61_orange-SWNE-060_farbe-left.png, 62_orange-SWNE-060_farbe-right.png
#         63_orange-SWNE-060_orient-left.png, 64_orange-SWNE-060_orient-right.png
#     legend PNGs in the stimuli\ folder
#         legend_gbNW.png, legend_poNE.png
#         legend_poNW.png, legend_gbNE.png
#
# version 2.0.0 - 2016, Laura Waite
############################################################################

#
# Variables
#
int block_trl_num = 0;                     # Trial number of the current block
int resp_cutoff = 1400;                    # Duration of stim2
int correctcounter = 0;                    # Number of correct responses in the current block
int incorrectcounter = 0;                  # Number of errors in the current block
int misscounter = 0;                       # Number of misses in the current block
int perc_incorrect = 0;                    # Percent errors in the current block
int perc_miss = 0;                         # Percent misses in the current block

#
# Portcode variables
#
#int deg_trg;
#int pcode_stim1;
#int pcode_stim2;

#
# read input file
#
preset string rule ;
preset string version;
string eventfile = "input\\" + rule + "_" + version + ".txt";
input_file events = new input_file;
events.open(eventfile);

array<int> event_num[2000];
array<int> stimuli[2000];    # avail_stims array number
array<int> color[2000];
array<string> direction[2000];
array<int> relevant_feature[2000];
array<int> congruency[2000];
array<int> answer[2000];
array<int> degrees[2000];
array<int> incon_freq[2000];
array<int> color_freq[2000];
array<int> color_answer[2000];
array<int> direc_answer[2000];
array<int> green_answer[2000];
array<int> blue_answer[2000];
array<int> pink_answer[2000];
array<int> orange_answer[2000];
array<int> SENW_answer[2000];
array<int> SWNE_answer[2000];
array<int> jitter[2000];
array<int> block_num[2000];
array<int> total_trials[0];

loop int i=1 until events.end_of_file()
begin
    event_num[i] = events.get_int();           # used only for input file
    stimuli[i] = events.get_int();
    color[i] = events.get_int();               # used only for output file
    direction[i] = events.get_string();        # used only for output file
    relevant_feature[i] = events.get_int();    # used only for output file
    congruency[i] = events.get_int();          # used only for output file
    answer[i] = events.get_int();
    degrees[i] = events.get_int();             # used only for output file
    incon_freq[i] = events.get_int();          # used only for output file
    color_freq[i] = events.get_int();          # used only for output file
    color_answer[i] = events.get_int();        # used only for output file
    direc_answer[i] = events.get_int();        # used only for output file
    green_answer[i] = events.get_int();        # used only for output file
    blue_answer[i] = events.get_int();         # used only for output file
    pink_answer[i] = events.get_int();         # used only for output file
    orange_answer[i] = events.get_int();       # used only for output file
    SENW_answer[i] = events.get_int();         # used only for output file
    SWNE_answer[i] = events.get_int();         # used only for output file
    jitter[i] = events.get_int();
    block_num[i] = events.get_int();
    total_trials.add(i);
    i=i+1;
end;
events.close();

#
# Set-up output file
#
string fdouble = "%10.3f";  # output format double
string fint = "%8d";        # output format int

string subject = logfile.filename();
output_file data = new output_file;
data.open(subject + ".txt");
# (headers) grn_ans  blu_ans  pnk_ans  org_ans  SENW_ans  SWNE_ans  trial  block  incon_freq  color_freq  congrueny   featr  color  color_ans  degrees  direc_ans  answer  stim1_onset  stim2_onset  reation_time  response   accuracy
data.print("grn_ans\tblu_ans\tpnk_ans\torg_ans\tSENW_ans\tSWNE_ans\ttrial\tblock\tincon_freq\tcolor_freq\tcongruency\tfeatr\tcolor\tcolor_ans\tdegrees\tdirec_ans\tanswer\tstim1_onset\tstim2_onset\treaction_time\tresponse\taccuracy\n");

#
# load stimuli pair arrays into a single array
#
array<bitmap> avail_stims[64][0];
avail_stims[1].assign(green_SENW_330_farbe_left);
avail_stims[2].assign(green_SENW_330_farbe_right);
avail_stims[3].assign(green_SENW_330_orient_left);
avail_stims[4].assign(green_SENW_330_orient_right);
avail_stims[5].assign(green_SENW_300_farbe_left);
avail_stims[6].assign(green_SENW_300_farbe_right);
avail_stims[7].assign(green_SENW_300_orient_left);
avail_stims[8].assign(green_SENW_300_orient_right);
avail_stims[9].assign(green_SWNE_030_farbe_left);
avail_stims[10].assign(green_SWNE_030_farbe_right);
avail_stims[11].assign(green_SWNE_030_orient_left);
avail_stims[12].assign(green_SWNE_030_orient_right);
avail_stims[13].assign(green_SWNE_060_farbe_left);
avail_stims[14].assign(green_SWNE_060_farbe_right);
avail_stims[15].assign(green_SWNE_060_orient_left);
avail_stims[16].assign(green_SWNE_060_orient_right);
avail_stims[17].assign(blue_SENW_330_farbe_left);
avail_stims[18].assign(blue_SENW_330_farbe_right);
avail_stims[19].assign(blue_SENW_330_orient_left);
avail_stims[20].assign(blue_SENW_330_orient_right);
avail_stims[21].assign(blue_SENW_300_farbe_left);
avail_stims[22].assign(blue_SENW_300_farbe_right);
avail_stims[23].assign(blue_SENW_300_orient_left);
avail_stims[24].assign(blue_SENW_300_orient_right);
avail_stims[25].assign(blue_SWNE_030_farbe_left);
avail_stims[26].assign(blue_SWNE_030_farbe_right);
avail_stims[27].assign(blue_SWNE_030_orient_left);
avail_stims[28].assign(blue_SWNE_030_orient_right);
avail_stims[29].assign(blue_SWNE_060_farbe_left);
avail_stims[30].assign(blue_SWNE_060_farbe_right);
avail_stims[31].assign(blue_SWNE_060_orient_left);
avail_stims[32].assign(blue_SWNE_060_orient_right);
avail_stims[33].assign(pink_SENW_330_farbe_left);
avail_stims[34].assign(pink_SENW_330_farbe_right);
avail_stims[35].assign(pink_SENW_330_orient_left);
avail_stims[36].assign(pink_SENW_330_orient_right);
avail_stims[37].assign(pink_SENW_300_farbe_left);
avail_stims[38].assign(pink_SENW_300_farbe_right);
avail_stims[39].assign(pink_SENW_300_orient_left);
avail_stims[40].assign(pink_SENW_300_orient_right);
avail_stims[41].assign(pink_SWNE_030_farbe_left);
avail_stims[42].assign(pink_SWNE_030_farbe_right);
avail_stims[43].assign(pink_SWNE_030_orient_left);
avail_stims[44].assign(pink_SWNE_030_orient_right);
avail_stims[45].assign(pink_SWNE_060_farbe_left);
avail_stims[46].assign(pink_SWNE_060_farbe_right);
avail_stims[47].assign(pink_SWNE_060_orient_left);
avail_stims[48].assign(pink_SWNE_060_orient_right);
avail_stims[49].assign(orange_SENW_330_farbe_left);
avail_stims[50].assign(orange_SENW_330_farbe_right);
avail_stims[51].assign(orange_SENW_330_orient_left);
avail_stims[52].assign(orange_SENW_330_orient_right);
avail_stims[53].assign(orange_SENW_300_farbe_left);
avail_stims[54].assign(orange_SENW_300_farbe_right);
avail_stims[55].assign(orange_SENW_300_orient_left);
avail_stims[56].assign(orange_SENW_300_orient_right);
avail_stims[57].assign(orange_SWNE_030_farbe_left);
avail_stims[58].assign(orange_SWNE_030_farbe_right);
avail_stims[59].assign(orange_SWNE_030_orient_left);
avail_stims[60].assign(orange_SWNE_030_orient_right);
avail_stims[61].assign(orange_SWNE_060_farbe_left);
avail_stims[62].assign(orange_SWNE_060_farbe_right);
avail_stims[63].assign(orange_SWNE_060_orient_left);
avail_stims[64].assign(orange_SWNE_060_orient_right);

#
# load legend pair arrays into a single array
#
array<bitmap> avail_legends[4][0];
avail_legends[1].assign(gbNW_poNE);
avail_legends[2].assign(poNW_gbNE);

#
# declare which legend from avail_legends to be used
#
int which_legend;
if (rule == "gbNW_poNE") then
    which_legend = 1;
elseif (rule == "poNW_gbNE") then
    which_legend = 2;
end;

#
# Main
#
loop int i=1 until i > total_trials.count()
begin
    # pause between blocks
    if (i != 1) then # but don't pause before the first trial
        if (block_num[i] != block_num[i-1]) then
            if (misscounter > 10) || (incorrectcounter < 10) then
                warn_txt.set_caption("Pause\n" + "Bitte schneller drücken!");
            else
                warn_txt.set_caption("Pause");
            end;
            warn_txt.redraw();
            pause.present();
            misscounter = 0;
            incorrectcounter = 0;
            correctcounter = 0;
        end;
    end;

    #Setup Portcodes
#    if (degrees[i] == 330) then
#        deg_trg = 3;
#    elseif (degrees[i] == 300) then
#        deg_trg = 6;
#    elseif (degrees[i] == 30) then
#        deg_trg = 3;
#    elseif (degrees[i] == 60) then
#        deg_trg = 6;
#    end;

#    pcode_stim1 = (direction[i]*100) + (color[i]*10) + deg_trg;
#    pcode_stim2 = (relevant_feature[i]*100) + (congruency[i]*10) + answer[i];
#    term.print(printf(pcode_stim1, fint) + "\n");
#    term.print(printf(pcode_stim2, fint) + "\n");

    # set event code for stim1
    # stim_event1.set_event_code(avail_stims[stimuli[i]][1].description());
    # set stimulus for stim1
    stim1.set_part(1, avail_stims[stimuli[i]][1]);
    # set legend for stim1
    stim1.set_part(2, avail_legends[which_legend][1]);
    stim1.set_part(3, avail_legends[which_legend][2]);
    # set portcode for stim1
#    stim_event1.set_port_code(pcode_stim1);

    # set event code for stim2
    # stim_event2.set_event_code(avail_stims[stimuli[i]][2].description());
    # set stimulus for stim2
    stim2.set_part(1, avail_stims[stimuli[i]][2]);
    # set legend for stim1
    stim2.set_part(2, avail_legends[which_legend][1]);
    stim2.set_part(3, avail_legends[which_legend][2]);
    # set jitter before stim2 onset
    stim_event2.set_time(jitter[i]);
    # set duration of stim2
    stim_event2.set_duration(resp_cutoff);
    # set portcode stim2
#    stim_event2.set_port_code(pcode_stim2);

    main_trial.present();

    # pull stimulus data for stim1
    stimulus_data timing_stim1 = stimulus_manager.get_stimulus_data((i*4)-3);
    # pull stimulus data for stim2
    stimulus_data info_stim2 = stimulus_manager.get_stimulus_data((i*4)-2);

    # give feedback
    feedback_pic.set_part(1, avail_stims[stimuli[i]][1]);
    if (info_stim2.button() == 0) then
        beep_event.set_stimulus(sounds[2]);
    else
        beep_event.set_stimulus(sounds[1]);
    end;
    feedback_trial.present();

    # pull stimulus data for wait event
    stimulus_data info_stim3 = stimulus_manager.get_stimulus_data((i*4)-1);

    # pull stimulus data for beep event
    stimulus_data info_sound = stimulus_manager.get_stimulus_data(i*4);

    # print to output file
    data.print(printf(green_answer[i], fint) + "\t");
    data.print(printf(blue_answer[i], fint) + "\t");
    data.print(printf(pink_answer[i], fint) + "\t");
    data.print(printf(orange_answer[i], fint) + "\t");
    data.print(printf(SENW_answer[i], fint) + "\t");
    data.print(printf(SWNE_answer[i], fint) + "\t");

    data.print(printf(i, fint) + "\t");                     # trial number

    data.print(printf(block_num[i], fint) + "\t");
    data.print(printf(incon_freq[i], fint) + "\t");
    data.print(printf(color_freq[i], fint) + "\t");

    data.print(printf(congruency[i], fint) + "\t");
    data.print(printf(relevant_feature[i], fint) + "\t");

    data.print(printf(color[i], fint) + "\t");
    data.print(printf(color_answer[i], fint) + "\t");

    data.print(printf(degrees[i], fint) + "\t");
    data.print(printf(direc_answer[i], fint) + "\t");

    data.print(printf(answer[i], fint) + "\t");

    data.print(printf(timing_stim1.time(), fint) + "\t");   # stim1 onset
    data.print(printf(info_stim2.time(), fint) + "\t");     # stim2 onset

    # Reaction Time
    if (info_stim2.button() == 0) then    # if no reponse or late reponse
        data.print("NaN" + "\t");
    else
        data.print(printf(info_stim2.reaction_time(), fint) + "\t");
    end;

    # Response
    if (info_stim2.button() == 1) then
        data.print(printf(-1, fint) + "\t");
    elseif(info_stim2.button() == 2) then
        data.print(printf(1, fint) + "\t");
    elseif(info_stim2.button() == 0) then
        data.print(printf(0, fint) + "\t");
    end;

    # Evaluate Response
    if (answer[i] == -1) then
        if (info_stim2.button() == 1) then
            correctcounter = correctcounter + 1;
            data.print(printf(1, fint) + "\t");
        elseif(info_stim2.button() == 0) then
            misscounter = misscounter + 1;
            data.print("NaN" + "\t");
        else
            incorrectcounter = incorrectcounter + 1;
            data.print(printf(-1, fint) + "\t");
        end;
    elseif (answer[i] == 1) then
        if (info_stim2.button() == 2) then
            correctcounter = correctcounter + 1;
            data.print(printf(1, fint) + "\t");
        elseif(info_stim2.button() == 0) then
            misscounter = misscounter + 1;
            data.print("NaN" + "\t");
        else
            incorrectcounter = incorrectcounter + 1;
            data.print(printf(-1, fint) + "\t");
        end;
    end;

    block_trl_num = block_trl_num +1;

    perc_incorrect = (incorrectcounter * 100) / block_trl_num;
    perc_miss = (misscounter * 100) / block_trl_num;

    if ((perc_incorrect < 10) && (resp_cutoff > 249)) then
        resp_cutoff = resp_cutoff - 10;
    elseif ((perc_incorrect > 15) && (resp_cutoff < 1400)) then
        resp_cutoff = resp_cutoff + 10;
    end;

    if ((perc_miss > 10) && (resp_cutoff < 1400)) then
        resp_cutoff = resp_cutoff + 10;
    end;

    term.print("\n" + "resp_cutoff=" + string(resp_cutoff));
    term.print("\n" + "incorrect_counter=" + string(incorrectcounter));
    term.print("\n" + "correct_counter=" + string(correctcounter));
    term.print("\n" + "miss_counter=" + string(misscounter));
    term.print("\n" + "block_trl_num=" + string(block_trl_num));
    term.print("\n" + "perc_incorrect=" + string(perc_incorrect));
    term.print("\n" + "perc_miss=" + string(perc_miss));

    data.print( "\n" );

    i=i+1;
end;

data.close(); # close output file
finish.present();
